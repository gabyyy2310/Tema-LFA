# Assignment 2 LFA ‚Äì RegEx Validator

**Author:** Pirvulescu Gabriela

## üìù General Description

This project aims to solve the problem of checking whether a given word belongs to the language generated by a regular expression (RegEx).

The provided code performs the following steps (whose combination solves our problem):

1. Converts a regular expression (RegEx) into postfix notation (RPN) using the **Shunting Yard** algorithm.
2. Builds an **NFA** (Non-deterministic Finite Automaton) from the postfix form using **Thompson's construction** algorithm.
3. Converts the NFA into a **DFA** (Deterministic Finite Automaton) using the **Subset Construction (Powerset Construction)** algorithm.
4. Checks if a given string is accepted by the DFA.

Tests are automatically loaded from a JSON file and evaluated. Output is displayed in the console after simply running (**RUN**) the program. For each sub-test case, **OK** will be shown if it passes and **FAIL** otherwise.

---

## üìÅ Project Structure

regex-matcher/
‚îÇ
‚îú‚îÄ‚îÄ main.py         ‚úÖ Python code for validating a string against a regular expression  
‚îú‚îÄ‚îÄ tests.json      ‚úÖ Test cases  
‚îî‚îÄ‚îÄ README.md       ‚úÖ Documentation  

---

## üîç Algorithms Used

### 1. `Shunting_Yard()` ‚Äì Converting a regular expression to postfix form
- Postfix notation is a way of writing expressions where operators always follow the operands they apply to (e.g., a.b (concatenation) becomes ab.).
- The algorithm transforms the regular expression into postfix form.
- Initially, it adds explicit concatenations (`.`) between adjacent symbols (because in the test files concatenation a.b is always written as ab, but our algorithm needs explicit symbols).
- Operator precedence is respected: `*`, `+`, `?`, `.`, `|` (using the `operators` dictionary) as well as associativity (using the `associativity` dictionary).
- A stack (in this case, a list simulating a stack) is used to store symbols and manage parentheses. Considering precedence, operators are added to the postfix expression. Any character that is not an operator is added directly to the postfix result when encountered.

### 2. `thompson()` ‚Äì Building an NFA from a postfix expression
- Applies **Thompson's algorithm** to build a non-deterministic finite automaton (NFA).
- A stack (list) is created to store components of the lambda-NFA (intermediate fragments) and each character of the postfix expression is processed.
- For each operator symbol encountered, the corresponding automata are simulated and pushed onto the stack. The correct NFA operations are performed according to the symbols.
- The postfix order is essential ‚Äî without it, this type of algorithm would not be possible. Postfix ensures NFAs are built in the correct order.
- A helper function converts the constructed lambda-NFA into the standard NFA form used in this project.

### 3. `nfa_to_dfa()` ‚Äì Subset Construction
- Converts the NFA into a DFA:
  - The NFA from Thompson‚Äôs algorithm is actually a lambda-NFA, but this does not affect the applicability of Subset Construction (we still refer to it simply as NFA).
  - DFA states are sets of NFA states.
  - For each set of states at a given moment, for each letter, we determine which states are reachable via that letter from the current set. If from set A we can reach set B via letter u, we add an edge labeled u in the DFA from A to B.
  - The initial state is the lambda-closure of the initial NFA state (all states reachable via lambda-moves from the NFA‚Äôs start state). In a plain NFA (no lambda transitions), the initial DFA state would simply be the set containing the NFA‚Äôs start state.
  - The DFA‚Äôs final states are all sets that contain at least one NFA final state.

### 4. `dfa_acceptance_check()` ‚Äì Validating strings with a DFA
- Starting from the initial state, checks if a final state can be reached by following the symbols in a given string.
- If it reaches `None` or encounters a symbol not in the alphabet, the string will be rejected.
- Returns `True` if the string is accepted, `False` otherwise.

---

## ‚úÖ Automated Testing

### JSON File (`tests.json`)
Contains a list of tests in the format:

```json
[
  {
    "name": "Test 1",
    "regex": "a(bc)*",
    "test_strings": [
      {"input": "abc", "expected": true},
      {"input": "a", "expected": true},
      {"input": "abcbc", "expected": true},
      {"input": "aaa", "expected": false}
    ]
  },
  {
    "name": "Test 2",
    "regex": "a*",
    "test_strings": [
      {"input": "a", "expected": true},
      {"input": "aaaa", "expected": true},
      {"input": "aa", "expected": true},
      {"input": "ba", "expected": false}
    ]
  }
]
